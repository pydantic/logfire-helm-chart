# ==============================================================================
# Global settings
# ==============================================================================

# -- Image pull secrets used by all pods
imagePullSecrets: []

# -- Node selector applied to all workloads
nodeSelector: {}

# -- Node/Pod affinity applied to all workloads
affinity: {}

# -- Tolerations applied to all workloads
tolerations: []

# -- Kubernetes cluster domain for service discovery
# clusterDomain: cluster.local

# -- Starter admin email address
adminEmail: hello@example.dev

# -- List of mapping to automatically assign members of OIDC group to logfire roles
groupOrganizationMapping: []
#  - group_id: "example-group-id"
#    organization_roles:
#      - organization_name: "org-1"
#        role: "admin"
#      - organization_name: "org-2"
#        role: "member"

# -- Configure Rate Limiting rules for Logfire endpoints
rateLimits: {}
#  queries:
#    perHour: 60
#    perMinute: 10

# ==============================================================================
# Ingress
# ==============================================================================

ingress:
  # -- Enable the Ingress resource.
  # If you are NOT using an ingress resource, you still need to set `tls` and `hostnames`
  # so the application can generate correct URLs/CORS.
  enabled: true

  # -- Enable TLS/HTTPS. Required for correct CORS behavior.
  tls: false

  # -- Hostname(s) for Pydantic Logfire.
  # Preferred method. Supports one or more hostnames; put the primary domain first.
  hostnames:
    - logfire.example.com

  # -- DEPRECATED (kept for backward compatibility).
  # Use `hostnames` (list) for all new deployments.
  hostname: "logfire.example.com"

  # -- IngressClass to use (e.g., nginx)
  ingressClassName: nginx

  # -- TLS Secret name if you want to do a custom one
  secretName: logfire-frontend-cert

  # -- Ingress annotations
  annotations: {}


# ==============================================================================
# Gateway API
# ==============================================================================

gateway:
  # -- Enable the Gateway API resources (Gateway and/or HTTPRoute).
  # Use this as an alternative to Ingress for environments using Gateway API.
  enabled: false

  # -- Create a Gateway resource. Set to false to use an existing Gateway.
  create: true

  # -- Name of the Gateway. Used for both created Gateway and HTTPRoute parentRef.
  # If not set, defaults to "logfire-gateway".
  name: ""

  # -- Namespace of an existing Gateway (only used when create is false).
  # Leave empty to use the same namespace as the HTTPRoute.
  namespace: ""

  # -- GatewayClass name to use (required when create is true).
  # Common values: istio, cilium, nginx, envoy-gateway, gke-l7-rilb, gke-l7-global-external-managed
  gatewayClassName: ""

  # -- Hostname(s) for the Gateway listener and HTTPRoute.
  # If not set, falls back to ingress.hostnames for backward compatibility.
  # These hostnames are also used for CORS/URL generation when gateway is enabled.
  hostnames: []
  #   - logfire.example.com

  # -- Enable TLS/HTTPS for the Gateway listener.
  # If not set, falls back to ingress.tls for backward compatibility.
  # Also affects CORS behavior (http vs https URLs).
  # @default -- nil (uses ingress.tls)
  tls:

  # -- TLS Secret name for the Gateway listener certificate.
  # If not set, falls back to ingress.secretName for backward compatibility.
  # @default -- nil (uses ingress.secretName)
  tlsSecretName:

  # -- Gateway annotations (only used when create is true)
  gatewayAnnotations: {}

  # -- Gateway labels (only used when create is true)
  gatewayLabels: {}

  # -- Gateway listeners configuration.
  # If not specified, a default HTTP/HTTPS listener will be auto-generated based on tls setting.
  listeners: []
  #   - name: https
  #     protocol: HTTPS
  #     port: 443
  #     tls:
  #       mode: Terminate
  #       certificateRefs:
  #         - name: logfire-tls-cert

  # -- Section name within the Gateway to attach the HTTPRoute to (optional).
  # Use this when the Gateway has multiple listeners.
  sectionName: ""

  # -- Gateway addresses (optional, only used when create is true).
  # Used to request specific addresses for the Gateway.
  addresses: []
  #   - type: IPAddress
  #     value: "192.168.1.100"

  # -- HTTPRoute annotations
  annotations: {}

  # -- HTTPRoute labels (in addition to standard labels)
  labels: {}

  # -- Path matches for the HTTPRoute rules.
  # Defaults to a single prefix match on "/" if not specified.
  matches: []
  #   - path:
  #       type: PathPrefix
  #       value: /

  # -- Additional HTTPRoute filters (e.g., request/response header modification).
  filters: []
  #   - type: RequestHeaderModifier
  #     requestHeaderModifier:
  #       add:
  #         - name: X-Custom-Header
  #           value: custom-value

  # -- Timeout settings for the HTTPRoute backend.
  timeouts: {}
  #   request: 60s
  #   backendRequest: 30s

  # -- Hostname for the maildev HTTPRoute (only used when dev.deployMaildev is true).
  # If not set, no hostname filter is applied to the maildev HTTPRoute.
  maildevHostname: ""


# ==============================================================================
# Postgres configuration
# ==============================================================================

# -- User-provided Secret containing database credentials
# Must include `postgresDsn` and `postgresFFDsn` keys.
postgresSecret:
  # -- Set to true to use an existing Secret (recommended for Argo CD users).
  enabled: false
  # -- Name of the Kubernetes Secret resource.
  name: ""
  # -- Optional annotations for the Secret (e.g., for external secret managers).
  annotations: {}

# -- Custom annotations for migration Jobs (uncomment as needed, e.g., with Argo CD hooks)
hooksAnnotations:
  # argocd.argoproj.io/hook: PreSync
  # argocd.argoproj.io/hook-delete-policy: HookSucceeded

# -- NOTE: The DSNs below are ignored if `postgresSecret.enabled` is true.

# -- Postgres DSN used for the `crud` database
postgresDsn: "postgresql://postgres:postgres@logfire-postgres:5432/crud"

# -- Postgres DSN used for the `ff` database
postgresFFDsn: "postgresql://postgres:postgres@logfire-postgres:5432/ff"


# ==============================================================================
# SMTP
# ==============================================================================

smtp:
  # -- SMTP server hostname
  host:
  # -- SMTP server port
  port: 25
  # -- SMTP username. Can be a plain string or a map with valueFrom (e.g., secretKeyRef).
  username:
  # -- SMTP password. Can be a plain string or a map with valueFrom (e.g., secretKeyRef).
  password:
  # -- Use TLS for SMTP
  use_tls: false

# SMTP example using secrets:
# smtp:
#   host: smtp.example.com
#   port: 587
#   username:
#     valueFrom:
#       secretKeyRef:
#         name: smtp
#         key: username
#   password:
#     valueFrom:
#       secretKeyRef:
#         name: smtp
#         key: password
#   use_tls: true


# ==============================================================================
# AI configuration
# ==============================================================================

ai:
  # -- AI provider+model string. Prefix the model with the provider (e.g., `azure:gpt-4o`).
  # See https://ai.pydantic.dev/models/ for more information.
  model:

  openAi:
    # -- OpenAI API key. Can be a plain string or a map with valueFrom (e.g., secretKeyRef).
    apiKey:

  vertexAi:
    # -- Vertex AI region
    region:

  azureOpenAi:
    # -- Azure OpenAI endpoint
    endpoint:
    # -- Azure OpenAI API key. Can be a plain string or a map with valueFrom (e.g., secretKeyRef).
    apiKey:
    # -- Azure OpenAI API version
    apiVersion:

# AI example using secrets:
# ai:
#   model: "openai:gpt-4o"
#   openAi:
#     apiKey:
#       valueFrom:
#         secretKeyRef:
#           name: openai
#           key: api-key
#   azureOpenAi:
#     endpoint: https://your-endpoint.openai.azure.com
#     apiKey:
#       valueFrom:
#         secretKeyRef:
#           name: azure-openai
#           key: api-key
#     apiVersion: "2024-05-01-preview"


# ==============================================================================
# Components
# ==============================================================================

# -- Configuration, autoscaling & resources for `logfire-dex` deployment
logfire-dex:
  # -- Workload labels
  labels: {}
  # -- Workload annotations
  annotations: {}
  # -- Pod labels
  podLabels: {}
  # -- Pod annotations
  podAnnotations: {}

  service:
    # -- Service annotations
    annotations: {}

  # -- Number of replicas
  replicas: 1

  # -- Dex configuration (see https://dexidp.io/docs/)
  config:
    # -- Enable password authentication.
    # Set to false if undesired, but ensure another connector is configured first.
    enablePasswordDB: true

    # -- Dex storage configuration (see https://dexidp.io/docs/configuration/storage/)
    storage:
      type: postgres
      config:
        host: logfire-postgres
        port: 5432
        user: postgres
        database: dex
        password: postgres
        ssl:
          mode: disable

    # -- Dex auth connectors (see https://dexidp.io/docs/connectors/)
    # The redirectURI can be omittedâ€”it will be generated automatically.
    # If specified, the custom value will be honored.
    connectors: []

  # -- Resource requests/limits
  resources:
    cpu: "250m"
    memory: "256Mi"

  # autoscaling:
  #   minReplicas: 1
  #   maxReplicas: 3
  #   hpa:
  #     enabled: true
  #     memAverage: 65
  #     cpuAverage: 60
  #   keda:
  #     enabled: true
  #     triggers:
  #       - type: cpu
  #         metricType: Utilization
  #         metadata:
  #           value: "50"
  # nodeSelector: {}
  # affinity: {}
  # tolerations: []
  # pdb:
  #   maxUnavailable: 1
  #   minAvailable: 1


# -- Autoscaling & resources for the `logfire-ff-ingest` pod
logfire-ff-ingest:
  # -- Workload labels
  labels: {}
  # -- Workload annotations
  annotations: {}
  # -- Pod labels
  podLabels: {}
  # -- Pod annotations
  podAnnotations: {}

  service:
    # -- Service annotations
    annotations: {}

  # -- Configuration for the StatefulSet PersistentVolumeClaim template
  volumeClaimTemplates:
    # -- Storage provisioned for each pod
    storage: 16Gi

  # //// Enables serviceName for older K8s versions
  # serviceName: true

  # resources:
  #   cpu: "2"
  #   memory: "4Gi"
  # autoscaling:
  #   minReplicas: 2
  #   maxReplicas: 24
  #   hpa:
  #     enabled: true
  #     memAverage: 40
  #     cpuAverage: 60
  #   keda:
  #     enabled: true
  #     triggers:
  #       - type: cpu
  #         metricType: Utilization
  #         metadata:
  #           value: "60"
  # nodeSelector: {}
  # affinity: {}
  # tolerations: []
  # pdb:
  #   maxUnavailable: 1
  #   minAvailable: 1

# -- Autoscaling & resources for the `logfire-ff-ingest-processor` pod
logfire-ff-ingest-processor:
  # -- Workload labels
  labels: {}
  # -- Workload annotations
  annotations: {}
  # -- Pod labels
  podLabels: {}
  # -- Pod annotations
  podAnnotations: {}

  service:
    # -- Service annotations
    annotations: {}

  # resources:
  #   cpu: "2"
  #   memory: "4Gi"
  # autoscaling:
  #   minReplicas: 2
  #   maxReplicas: 24
  #   hpa:
  #     enabled: true
  #     memAverage: 50
  #     cpuAverage: 80
  #   keda:
  #     enabled: true
  #     triggers:
  #       - type: cpu
  #         metricType: Utilization
  #         metadata:
  #           value: "70"
  # nodeSelector: {}
  # affinity: {}
  # tolerations: []
  # pdb:
  #   maxUnavailable: 1
  #   minAvailable: 1


# -- Autoscaling & resources for the `logfire-backend` pod
# logfire-backend:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   # -- Number of replicas
#   replicas: 2
#   # -- Resource requests/limits
#   resources:
#     cpu: "600m"
#     memory: "1Gi"
#   # -- Autoscaler settings
#   autoscaling:
#     minReplicas: 2
#     maxReplicas: 4
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the query API pods
# logfire-ff-query-api:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   # -- Parallelism per pod
#   queryParallelism: 4
#   # -- Number of replicas
#   replicas: 2
#   resources:
#     cpu: "500m"
#     memory: "2Gi"
#   autoscaling:
#     minReplicas: 2
#     maxReplicas: 8
#     hpa:
#       enabled: true
#       memAverage: 70
#       cpuAverage: 60
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the frontend pods
# logfire-frontend-service:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 1
#   resources:
#     cpu: "100m"
#     memory: "128Mi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 3
#     hpa:
#       enabled: true
#       memAverage: 70
#       cpuAverage: 60
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the worker pods
# logfire-worker:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   replicas: 1
#   resources:
#     cpu: "125m"
#     memory: "512Mi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 5
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 70
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the proxy pods
# logfire-service:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 1
#   resources:
#     cpu: "1"
#     memory: "1Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 3
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 20
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the byte cache pods
# logfire-ff-cache-byte:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   # -- Number of replicas
#   replicas: 2
#   resources:
#     cpu: "1"
#     memory: "6Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 6
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 20
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1
#   scratchVolume:
#     storageClassName: my-storage-class
#     storage: 128Gi
#     labels:
#       type: my-volume


# -- Autoscaling & resources for the IPC cache pods
# logfire-ff-cache-ipc:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   # -- Number of replicas
#   replicas: 1
#   resources:
#     cpu: "2"
#     memory: "8Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 3
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the Filter cache pods
# logfire-ff-cache-filter:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   # -- Number of replicas
#   replicas: 1
#   resources:
#     cpu: "500m"
#     memory: "2Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 2
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the byte proxy cache pods
# logfire-ff-proxy-cache-byte:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 2
#   resources:
#     cpu: "750m"
#     memory: "768Mi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 2
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the IPC proxy cache pods
# logfire-ff-proxy-cache-ipc:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 2
#   resources:
#     cpu: "250m"
#     memory: "256Mi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 2
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Autoscaling & resources for the filter proxy cache pods
# logfire-ff-proxy-cache-filter:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 2
#   resources:
#     cpu: "250m"
#     memory: "256Mi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 2
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 40
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- Maintenance worker
# logfire-ff-maintenance-worker:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   jobParallelism: 3
#   downloadParallelism: 10
#   replicas: 2
#   datafusionMemory: "3072MB"
#   compactionTiers:
#     - size_threshold_bytes: "1KB"
#       count_threshold: 10
#     - size_threshold_bytes: "10KB"
#       count_threshold: 10
#     - size_threshold_bytes: "100KB"
#       count_threshold: 10
#     - size_threshold_bytes: "1MB"
#       count_threshold: 10
#     - size_threshold_bytes: "10MB"
#       count_threshold: 10
#     - size_threshold_bytes: "100MB"
#       count_threshold: 10
#   resources:
#     cpu: "2"
#     memory: "8Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 3
#     hpa:
#       enabled: true
#       memAverage: 50
#       cpuAverage: 50
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1
#   scratchVolume:
#     storageClassName: my-storage-class
#     storage: 1Gi
#     labels:
#       type: my-volume


# -- Compaction worker
# logfire-ff-compaction-worker:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   jobParallelism: 4
#   downloadParallelism: 10
#   replicas: 2
#   datafusionMemory: "3072MB"
#   compactionTiers:
#     - size_threshold_bytes: "1KB"
#       count_threshold: 10
#     - size_threshold_bytes: "10KB"
#       count_threshold: 10
#     - size_threshold_bytes: "100KB"
#       count_threshold: 10
#     - size_threshold_bytes: "1MB"
#       count_threshold: 10
#     - size_threshold_bytes: "10MB"
#       count_threshold: 10
#     - size_threshold_bytes: "100MB"
#       count_threshold: 10
#   resources:
#     cpu: "2"
#     memory: "8Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 6
#     hpa:
#       enabled: true
#       memAverage: 50
#       cpuAverage: 85
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1
#   scratchVolume:
#     storageClassName: my-storage-class
#     storage: 1Gi
#     labels:
#       type: my-volume


# -- OpenTelemetry collector
# logfire-otel-collector:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   resources:
#     cpu: "1"
#     memory: "1Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 2
#     hpa:
#       enabled: true
#       memAverage: 70
#       cpuAverage: 60
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# -- CRUD API
# logfire-ff-crud-api:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   service:
#     # -- Service annotations
#     annotations: {}
#   replicas: 2
#   resources:
#     cpu: "500m"
#     memory: "1Gi"
#   autoscaling:
#     minReplicas: 1
#     maxReplicas: 6
#     hpa:
#       enabled: true
#       memAverage: 65
#       cpuAverage: 20
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "20"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


## Optional query worker deployment
# logfire-ff-query-worker:
#   # -- Workload labels
#   labels: {}
#   # -- Workload annotations
#   annotations: {}
#   # -- Pod labels
#   podLabels: {}
#   # -- Pod annotations
#   podAnnotations: {}
#   enabled: true
#   replicas: 8
#   resources:
#     cpu: "500m"
#     memory: "4Gi"
#   autoscaling:
#     minReplicas: 8
#     maxReplicas: 128
#     hpa:
#       enabled: true
#       memAverage: 20
#       cpuAverage: 50
#     keda:
#       enabled: true
#       triggers:
#         - type: cpu
#           metricType: Utilization
#           metadata:
#             value: "50"
#   nodeSelector: {}
#   affinity: {}
#   tolerations: []
#   pdb:
#     maxUnavailable: 1
#     minAvailable: 1


# ==============================================================================
# Object storage
# ==============================================================================

# -- Object storage details
objectStore:
  # -- URI for object storage (e.g., `s3://bucket`)
  uri:
  # -- Additional environment variables for the object store connection
  env: {}
  # -- Volume mounts for object store credentials
  volumeMounts: []
  # -- Volumes for object store credentials
  volumes: []

# Azure example:
# objectStore:
#   uri: az://<container_name>
#   env:
#     AZURE_STORAGE_ACCOUNT_NAME: <storage_account_name>
#     AZURE_STORAGE_ACCOUNT_KEY:
#       valueFrom:
#         secretKeyRef:
#           name: my-azure-secret
#           key: account-key
#
# AWS example:
# objectStore:
#   uri: s3://<bucket_name>
#   env:
#     AWS_DEFAULT_REGION: <region>
#     AWS_SECRET_ACCESS_KEY:
#       valueFrom:
#         secretKeyRef:
#           name: my-aws-secret
#           key: secret-key
#     AWS_ACCESS_KEY_ID: <access_key>


# ==============================================================================
# Service account / priority / rollout policy / security
# ==============================================================================

# -- ServiceAccount used by pods
serviceAccountName: default

# -- Pod priority class
# See: https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority).
priorityClassName: ""

# -- Number of deployment revisions to keep.
# See: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#clean-up-policy)
# May be set to 0 when using a GitOps workflow.
revisionHistoryLimit: 2

# -- Pod SecurityContext (https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod)
# See: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context for details
podSecurityContext: {}
  # fsGroup: 2000

# -- Container SecurityContext (https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container)
# See: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-1 for details
securityContext: {}
  # capabilities:
  #   drop:
  #     - ALL
  # runAsNonRoot: true
  # runAsUser: 1000
  # readOnlyRootFilesystem: true


# ==============================================================================
# Images
# ==============================================================================

image:
  # -- Image pull policy
  pullPolicy: IfNotPresent
  # @ignored
  repository: us-docker.pkg.dev/pydantic-public-registries/logfire/
  # @ignored
  workerImage: python-prod
  # @ignored
  backendImage: python-prod
  # @ignored
  frontendImage: frontend
  # @ignored
  fusionfireImage: fusionfire
  # @ignored
  dexImage: dex

# -- HAProxy image configuration (used by the service and feature-flag proxies)
haproxy:
  image:
    repository: haproxy
    tag: "3.2"
    pullPolicy: IfNotPresent


# ==============================================================================
# Redis
# ==============================================================================

logfire-redis:
  # -- Deploy Redis as part of this chart.
  # Disable to use an external Redis instance.
  enabled: true

  # -- Redis image configuration
  image:
    # -- Redis image repository
    repository: redis
    # -- Redis image tag
    tag: "7.2"
    # -- Redis image pull policy
    pullPolicy: IfNotPresent

# -- Redis DSN. Change if using an external Redis instance.
redisDsn: redis://logfire-redis:6379


# ==============================================================================
# OpenTelemetry Collector
# ==============================================================================

# -- otel-collector configuration
otel_collector:
  image:
    repository: ghcr.io/open-telemetry/opentelemetry-collector-releases/opentelemetry-collector-contrib
    tag: "0.139.0"
    pullPolicy: IfNotPresent
  prometheus:
    enabled: false
    port: 9090
    endpoint: "0.0.0.0"
    send_timestamp: true
    metric_expiration: 180m
    enable_open_metrics: true
    add_metric_suffixes: false
    resource_to_telemetry_conversion:
      enabled: true


# ==============================================================================
# Secrets (JWT/tokens and admin credentials)
# ==============================================================================

# -- Existing Secret with the following keys:
#  - logfire-dex-client-secret
#  - logfire-meta-write-token
#  - logfire-meta-frontend-token
#  - logfire-jwt-secret
existingSecret:
  # -- Use an existing Secret (recommended for Argo CD users).
  enabled: false
  # -- Name of the Kubernetes Secret resource.
  name: ""
  # -- Optional annotations for the Secret (e.g., for external secret managers).
  annotations: {}

# -- Existing Secret with the following keys:
#  - logfire-admin-password
#  - logfire-admin-totp-secret
#  - logfire-admin-totp-recovery-codes (string containing a JSON list)
adminSecret:
  # -- Use an existing Secret (recommended for Argo CD users).
  enabled: false
  # -- Name of the Kubernetes Secret resource.
  name: ""
  # -- Optional annotations for the Secret (e.g., for external secret managers).
  annotations: {}


# ==============================================================================
# Development conveniences (NOT for production)
# ==============================================================================

dev:
  # -- Deploy MailDev to test emails
  deployMaildev: false
  # -- Deploy internal Postgres (NOT for production)
  deployPostgres: false
  # -- Use a local MinIO instance as object storage (NOT for production)
  deployMinio: false

# -- MailDev image configuration (only used when `dev.deployMaildev` is true)
maildev:
  image:
    repository: maildev/maildev
    tag: latest
    pullPolicy: IfNotPresent


# ==============================================================================
# Embedded Postgres & MinIO defaults (dev/test)
# ==============================================================================

postgresql:
  image:
    registry: docker.io
    repository: bitnamilegacy/postgresql
  fullnameOverride: "logfire-postgres"
  auth:
    postgresPassword: "postgres"
  postgresqlDataDir: /var/lib/postgresql/data/pgdata
  primary:
    resourcesPreset: small
    initdb:
      scripts:
        create_databases.sql: |
          CREATE DATABASE crud;
          CREATE DATABASE dex;
          CREATE DATABASE ff;
    persistence:
      size: 10Gi
      mountPath: /var/lib/postgresql

minio:
  image:
    registry: docker.io
    repository: bitnamilegacy/minio
  console:
    image:
      registry: docker.io
      repository: bitnamilegacy/minio-object-browser
  fullnameOverride: "logfire-minio"
  auth:
    rootUser: logfire-minio
    rootPassword: logfire-minio
  persistence:
    mountPath: /data
    size: 32Gi
  command:
    - minio
  args:
    - server
    - /data
  lifecycleHooks:
    postStart:
      exec:
        command:
          - sh
          - -c
          - |
            # Wait for the server to start
            sleep 5
            # Create a bucket
            mc alias set local http://localhost:9000 logfire-minio logfire-minio
            mc mb local/logfire
            mc anonymous set public local/logfire

# ==============================================================================
# Extra Kubernetes manifests
# ==============================================================================

# -- Additional Kubernetes objects to render with this release. Templating is supported.
extraObjects: []
#  - apiVersion: v1
#    kind: ConfigMap
#    metadata:
#      name: additional-config
#      namespace: "{{ .Release.Namespace }}"
#    data:
#      key: value
